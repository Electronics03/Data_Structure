# 포인터 배열과 배열 포인터

## 포인터 배열

### 문법

```c
자료형 *배열이름[배열크기];
```

- `자료형 *`: 배열의 요소가 가리키는 데이터의 자료형.
- `배열이름`: 배열의 이름.
- `배열크기`: 배열에 포함된 포인터의 개수.

### 특징

- 각 배열 요소는 포인터이며, 데이터의 메모리 주소를 저장한다.
- 배열 내의 포인터는 서로 다른 변수나 데이터 구조를 가리킬 수 있다.
- 문자열 배열처럼 여러 문자열을 다룰 때 유용하다.

### 예시

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() 
{
    int a = 10;
    int b = 20;
    int c = 30;

    int* arr[3] = { 0 };

    // 포인터 배열 초기화
    arr[0] = &a;
    arr[1] = &b;
    arr[2] = &c;

    // 출력
    for (int i = 0; i < 3; i++) 
    {
        printf("arr[%d] = %p\n", i, arr[i]);
        printf("*(arr + %d) = %p\n", i, *(arr + i));
        printf("*arr[%d] = %d\n", i, *arr[i]);
        printf("**(arr + %d) = %d\n\n", i, **(arr + i));
    }

    return 0;
}
```

```
arr[0] = 00000077D0B2F704
*(arr + 0) = 00000077D0B2F704
*arr[0] = 10
**(arr + 0) = 10

arr[1] = 00000077D0B2F724
*(arr + 1) = 00000077D0B2F724
*arr[1] = 20
**(arr + 1) = 20

arr[2] = 00000077D0B2F744
*(arr + 2) = 00000077D0B2F744
*arr[2] = 30
**(arr + 2) = 30
```

## 문자열과 포인터 배열

문자열들을 저장하는 2차원 배열의 각 행은 저장하는 문자열 중 가장 긴 문자열이 들어갈 수 있는 크기여야 한다. 따라서 문자열들의 길이가 서로 다르다면 낭비되는 메모리가 발생할 수 있다. 이는 포인터 배열을 이용하여 해결할 수 있다.

문자열 리터럴을 다룰 때 포인터 배열은 매우 유용하다. 문자열 리터럴은 읽기 전용 메모리 영역에 저장되며, 이들의 주소를 관리하는 데 포인터 배열이 효과적이다. 

### 특징

- 메모리 효율성
    - 문자열 리터럴은 이미 메모리에서 읽기 전용 영역에 저장된다.
    - 포인터 배열을 사용하면 각 문자열의 복사본을 만들 필요 없이 주소를 저장하여 관리할 수 있다.
    - 포인터 배열을 사용하면 문자열 크기에 관계없이 문자열을 동적으로 처리할 수 있다.
- 메모리 정렬
    - CPU 아키텍처와 메모리 정렬 규칙에 따라 문자열 리터럴의 시작 주소가 특정 정렬 기준에 맞춰질 수 있다. 하지만 문자열 데이터 자체에는 영향을 미치지 않는다.
- 연속된 메모리 공간
    - 문자열 리터럴은 읽기 전용 메모리의 연속된 메모리 공간에 저장된다.
    - 문자열 끝에는 반드시 널 문자(`\0`)가 추가되어 문자열의 끝을 표시한다.
- 패딩 없음
    - 문자열 리터럴은 문자 하나당 1바이트를 차지하며, 각 문자는 인접한 메모리 위치에 저장된다.
    - 따라서 문자열 리터럴 자체는 패딩을 포함하지 않는다.
- 다양한 문자열 관리
    - 여러 개의 문자열 리터럴을 쉽게 처리하거나, 반복적으로 접근할 수 있다.
    - 문자열 리터럴의 포인터를 배열로 관리하면 코드가 단순해지고 가독성이 높아진다.

### 예시

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>

int main(void)
{
	const char* ptrStr[] =
	{
		"Apple",
		"BlueBerry",
		"Orange"
	};

	for (int i = 0; i < 3; i++)
	{
		printf("%s\n", ptrStr[i]);
		printf("%p\n\n", ptrStr[i]);
	}
	return 0;
}
```

```
Apple
00007FF62E21ACF4

BlueBerry
00007FF62E21AD00

Orange
00007FF62E21AD0C
```

## 배열 포인터

배열 포인터는 배열을 가리키는 포인터이다. 이는 배열 전체를 가리키며, 배열의 시작 주소를 저장하는 포인터와는 다르다. 주로 다차원 배열을 처리하거나 배열을 함수에 전달할 때 사용된다.

배열의 이름은 포인터처럼 작동하지만 상수 포인터로 간주되어 값을 변경할 수 없다. 따라서 같은 크기의 여러 배열을 효율적으로 처리하려면 배열 포인터를 사용하여 배열들의 시작 주소를 순회하며 처리하는 것이 좋은 방법이다. 

이러한 상황에서 배열 포인터를 이용하면 코드가 간결하고 효율적으로 배열을 관리할 수 있다.

### 문법

```c
자료형 (*포인터이름)[배열크기];
```

- `자료형` : 배열 요소의 자료형.
- `(*포인터이름)` : 포인터 변수를 가리킴.
- `[배열크기]` : 배열의 크기(컴파일러에 알려줘야 함).

### 특징

- `*` 와 `[]` 의 위치에 주의해야 한다. `(*포인터이름)` 은 배열을 가리키는 포인터를 의미한다.
- 포인터는 배열의 시작 주소를 가리키며, 배열 크기를 유지한다.
- 다차원 배열에서 각 행(row)을 가리키는 데 배열 포인터를 사용할 수 있다.
- `자료형 (*포인터이름)[열의 크기] = 다차원 배열의 행`

### 예시

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

void printRow(int (*arrays)[4])
{
    // int (*)[4] 형태의 주소를 받고 출력하는 함수
    // 하나의 행을 출력한다
    for (int i = 0; i < 4; i++)
        printf("%d ", (*arrays)[i]);
    return;
}

int main(void) 
{
    // 2차원 배열 선언
    int arr[3][4] = 
    { 
        { 1, 2, 3, 4 },
        { 5, 6, 7, 8 },
        { 9, 10, 11, 12 } 
    };

    // 배열 포인터를 순회하며 배열 처리
    for (int i = 0; i < 3; i++) 
    {
        printRow((int (*)[4])arr[i]);
        printf("\n");
    }
    return 0;
}
```

```
1 2 3 4
5 6 7 8
9 10 11 12
```