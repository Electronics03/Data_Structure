# Integer

## 1. 정수형이란?

C 언어에서 정수형(Integer Type)은 정수 값을 저장하고 처리하기 위한 자료형이다. 

정수형은 부호가 있는지 여부(`signed`/`unsigned`), 크기(`short`, `int`, `long`, `long long`)에 따라 다양한 종류를 제공하며, 각각 저장 가능한 값의 범위와 메모리 크기가 다르다.

## 2. 2’s Complement 표현법

2의 보수(2's Complement) 표현법은 컴퓨터에서 정수를 표현하는 표준적인 방법 중 하나로, C 언어에서 정수형 데이터는 이 표현법을 사용하여 저장 및 연산된다.

이 표현법은 음수 표현을 가능하게 하며, 덧셈과 뺄셈 같은 연산을 단순화하고, 하드웨어 설계를 효율적으로 구현할 수 있도록 설계되었다.

### 2의 보수 표현법

- 2의 보수 표현법은 이진수로 양수와 음수를 표현하는 방법이다.
- 가장 왼쪽 비트(최상위 비트, MSB)는 부호 비트로 사용된다.
- **양수**는 이진수로 그대로 표현된다.
- 음수는 해당 숫자의 양수를 이진수로 변환한 후, 모든 비트를 반전(1을 0으로, 0을 1로)시키고, 여기에 1을 더하여 표현한다.

### 2의 보수 표현 예시

- **예시: 20 `0001 0100`**
    1. 20을 이진수 그대로 표현한다: **`0001 0100`**
    
    | Bit | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    | --- | --- | --- | --- | --- | --- | --- | --- | --- |
    |  | +/- | 64 | 32 | 16 | 8 | 4 | 2 | 1 |
    | 숫자 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |
- **예시: -20 `11101100`**
    1. 모든 비트를 반전시킨다: **`0001 0100` → `1110 1011`**
    2. 1을 더한다: **`1110 1011` + `1`  → `11101100`** 
    
    | Bit | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    | --- | --- | --- | --- | --- | --- | --- | --- | --- |
    |  | +/- | 64 | 32 | 16 | 8 | 4 | 2 | 1 |
    | 숫자 | 1 | 1 | 1 | 0 | 1 | 1 | 0 | 0 |

### 2의 보수 표현의 장점

- 2의 보수 방식은 0을 유일하게 하나의 표현으로 나타낼 수 있다.
- 음수와 양수의 계산이 간단하고 효율적으로 이루어진다.
- 덧셈과 뺄셈을 동일한 방식으로 처리할 수 있어 계산이 직관적이다.

## 3. 2’s Complement 덧셈 방법

2의 보수에서 덧셈을 수행하는 방법은 1의 보수와 달리 단순히 **이진수 덧셈만 수행하면 되는 방식이다**. 캐리를 다시 더해줄 필요가 없기 때문에 2의 보수 방식은 컴퓨터 시스템에서 널리 사용된다.

2의 보수에서 뺄셈을 수행할 때는 빼는 숫자의 부호를 반대로 한 뒤, 덧셈을 수행한다. 덧셈으로 두 수를 단순히 더한 후, 초과하는 캐리 비트가 있으면 무시하면 된다.

### 예시 1: -5와 3을 더하기

1. **이진수 표현**:
    - 양수 5를 8비트로 표현: `0000 0101`
    - 5의 2의 보수 (-5): `1111 1011` (1의 보수 `1111 1010` 에 1을 더함)
    - 3을 8비트로 표현: `0000 0011`
2. **2의 보수 덧셈 수행**:
    
    ```
      1111 1011  (-5)
    + 0000 0011  (+3)
    --------------
    1 1111 1110  (9비트, 초과된 캐리 비트 무시)
    ```
    
3. **결과 해석**:
    - 결과는 `1111 1110` 로, 이는 -2을 의미한다.
    - 따라서, -5와 3을 더한 결과는 -2.

### 예시 2: -3에서 2 빼기

1. **이진수 표현**:
    - 양수 3을 8비트로 표현: `0000 0011`
    - 3의 2의 보수 (-3): `1111 1101` (1의 보수 `1111 1100` 에 1을 더함)
    - 양수 2를 8비트로 표현: `0000 0010`
    - 2의 2의 보수 (-2): `1111 1110` (1의 보수 `1111 1101` 에 1을 더함)
2. **2의 보수 덧셈 수행**:
    
    ```
      1111 1101  (-3)
    + 1111 1110  (-2)
    --------------
    1 1111 1011  (9비트, 초과된 캐리 비트 무시)
    ```
    
3. **결과 해석**:
    - 결과는 `1111 1011`로, 이는 2의 보수에서 -5를 나타낸다.
    - 따라서, -3과 -2를 더한 결과는 -5.

### 2의 보수와 1의 보수 뎃셈 차이 (그림)

![스크린샷(78).png](스크린샷(78).png)

## 4. 정수형 변수의 종류와 크기

| 자료형 | 메모리 크기 | 값의 범위 (signed) | 값의 범위 (unsigned) |
| --- | --- | --- | --- |
| `int` | 4 bytes | -2,147,483,648 ~ 2,147,483,647 | 0 ~ 4,294,967,295 |
| `short` | 2 bytes | -32,768 ~ 32,767 | 0 ~ 65,535 |
| `long` | 4 bytes (32-bit 시스템) 또는 8 bytes (64-bit 시스템) | -2,147,483,648 ~ 2,147,483,647 (32-bit) | 0 ~ 4,294,967,295 |
| `long long` | 8 bytes | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 0 ~ 18,446,744,073,709,551,615 |

## 5. signed / unsigned

- **`signed` (기본값):** 음수와 양수를 모두 저장.
- **`unsigned`:** 양수만 저장하며, 저장 가능한 값의 범위가 2배로 확장.

```c
signed int x = -100;  // 음수 가능, 생략 가능
unsigned int y = 100; // 양수만 가능
```

## 6. 예시 코드

```c
int number = -31415;
short shortNumber = -1234;
long longNumber = -314159265;
long long greatNumber = -3141592653589;
// signed 정수 선언과 초기화
// 크기는 다음과 같다 
// int -> 4
// short -> 2
// long -> 4
// long long -> 8

unsigned u_number = 31415;
unsigned short u_shortNumber = 1234;
unsigned long u_longNumber = 314159265;
unsigned long long u_greatNumber = 3141592653589;
// unsigned 정수 선언과 초기화
// 크기는 다음과 같다 
// unsigned (int) -> 4
// unsigned short -> 2
// unsigned long -> 4
// unsigned long long -> 8
```