# Floating Point

C++ 에서 부동소수점(Floating Point)은 실수를 저장하고 처리하는 데 사용된다. 

부동소수점 자료형은 소수점 이하의 값을 포함할 수 있으며, 정수형과 달리 매우 큰 값 또는 매우 작은 값을 표현할 수 있다. 

C++ 에서 제공하는 부동소수점 자료형은 `float` , `double` , `long double` 세 가지가 있다.

## 1. 부동소수점 자료형의 종류

| 자료형 | 크기 (바이트) | 표현 범위 | 정밀도 (유효 자릿수) |
| --- | --- | --- | --- |
| `float` | 4 bytes | ±1.2E-38 ~ ±3.4E+38 | 약 6~7자리 |
| `double` | 8 bytes | ±2.3E-308 ~ ±1.7E+308 | 약 15~16자리 |
| `long double` | 10~16 bytes | 구현에 따라 다름 (더 높은 정밀도 제공) | 구현에 따라 다름 |

## 2. IEEE 754 (부동소수점 표현 방식)

IEEE 754는 컴퓨터에서 부동소수점을 표현하고 연산하는 표준이다. 

### 1) IEEE 754에서 실수를 표현하는 공식

$$
Value=(−1)Sign×2^{Exponent−Bias}×(1.Mantissa)
$$

- Sign: 부호 비트 (0: 양수, 1: 음수)
- Exponent: 지수값 (바이어스가 적용됨)
- Bias: `float` 는 127, `double` 는 1023
- Mantissa: 가수 부분(정규화된 값, 숨겨진 1 포함)

### 2) 바이어스가 존재하는 이유

지수 값(Exponent)은 음수와 양수를 모두 표현해야 한다. 그러나, 컴퓨터에서 음수 값을 저장하려면 추가적인 처리가 필요하므로, 이를 단순화하기 위해 바이어스(Bias)를 사용하여 음수 지수를 양수로 변환한다.

- **예시:**
    - 지수값 -3: 바이어스 127을 더해 저장 시 127−3=124로 저장.
    - 지수값 +5: 바이어스 127을 더해 저장 시 127+5=132로 저장.

이 방식은 음수 지수를 포함한 실수의 표현을 효율적으로 처리할 수 있도록 도와준다.

### 3) IEEE 754의 형식들

IEEE 754는 주로 다음 두 가지 형식을 제공한다:

- **단정밀도(Single Precision): 32비트 `float`**
    
    
    | 비트 구분 | 크기 | 설명 |
    | --- | --- | --- |
    | 부호 | 1비트 | 숫자가 양수인지 음수인지를 나타냄 |
    | 지수 | 8비트 | 소수점의 위치를 나타내며, 바이어스(127)가 적용 |
    | 가수 | 23비트 | 실수의 유효 숫자 부분 (숨겨진 1 포함) |
- **배정밀도(Double Precision): 64비트 `double`**
    
    
    | 비트 구분 | 크기 | 설명 |
    | --- | --- | --- |
    | 부호 | 1비트 | 숫자가 양수인지 음수인지를 나타냄 |
    | 지수 | 11비트 | 소수점의 위치를 나타내며, 바이어스(1023)가 적용 |
    | 가수 | 52비트 | 실수의 유효 숫자 부분 (숨겨진 1 포함) |

### 4) 실수를 부동소수점 형식으로 표현하는 예시

`-12.375` 를 단정밀도 부동소수점(`float`)으로 표현해보자.

1. 부호(Sign): 음수이므로 `Sign = 1`.
2. 이진수 변환: `12.375`를 이진수로 변환하면 `1100.011`이다.
3. 정규화: `1.100011 × 2^3` (소수점 이동).
4. 지수(Exponent): 3+127=130, `10000010`.
5. 가수(Mantissa): `100011` (정규화된 1 제외).

```
1 | 10000010 | 10001100000000000000000
```

### 5) 정의된 특별한 값들

- **0**:
    - 부호 비트는 양수 또는 음수(0 또는 1).
    - 지수와 가수는 모두 0으로 설정.
    - `0 00000000 00000000000000000000000`
- **무한대 (Infinity)**:
    - 지수가 모두 1이고, 가수가 0.
    - 양수 무한대: `0 11111111 00000000000000000000000`
    - 음수 무한대: `1 11111111 00000000000000000000000`
- **NaN (Not a Number)**:
    - 지수가 모두 1이고, 가수가 0이 아닌 경우.
    - 연산 불가능한 결과(0으로 나누기, 불가능한 연산 등).
    - `0 11111111 10010011001001100000000`
- **서브노멀 숫자 (Subnormal Numbers)**:
    - 지수가 모두 0이고, 가수가 0이 아닌 경우.
    - 매우 작은 값을 표현하며 정규화되지 않은 숫자.
    - `0 00000000 10010011001001100000000`

## 3. 부동소수점 연산의 특징

### 1) 연산 속도

- 부동소수점 연산은 정수 연산보다 느리다.
- 부동소수점 연산에는 ALU이외에 전용 FPU(Floating Point Unit)를 사용하는 경우가 많다.

### 2) 연산 오차

- 덧셈, 곱셈 등 부동소수점 연산에는 오차가 포함될 수 있다.
- 예를 들어, `(0.1 + 0.2) != 0.3`이 될 수 있다.

### 3) 부동소수점 사용 시 주의점

- 반복 계산이나 매우 작은 값을 처리할 때 정밀도 문제가 발생할 수 있다.
- 부동소수점 값을 비교할 때는 직접 비교하지 말고, 오차 범위(epsilon)를 고려해야 한다.